function [imageFinal state o logs] = simul8tr(state, varargin)
% function [image state o logs] = simul8tr(state, varargin)
% Purpose:
% Simulate and network of Brownian particles connected by springs
% as viewed through a microscope.
%
% Input:
%   all input is optional. Code will run as simul8tr([]), carrying out the
%   default simulation.
%
%   state -- population structure generated by the code.  Use an empty array
%   for most runs. Use the structure output by the code to restart a
%   simulation.
%   optional struct of simulation options --  See code below for interpretation of
%   the options.  Default values are supplied for all options and used for
%   any option that is left out.
%
% Output:
%   postConv -- an (y,x,time) array of simulated microscope images
%   state    -- a struct containing the state of the system, to be used for
%               restarts
%   o       -- all the options used in the simulations, including all the
%   defaults and user
%   logs -- logs currently pre-convolution images (i.e. plain plots of the
%   nodes and bonds) if the debug option is set to 1 as well as a plot of
%   ensemble mean bond length at every iteration.
%
% Example:
% [postConv state o logs] = simul8tr(state, varargin)
%   This runs a single frame simulation of Brownian particles
% Based on original code by David Kolin and Paul Wiseman of McGill
% University.
%
% Kirill Titievsky
% kir@mit.edu
%
%
% -

% interpret the input
o_base = struct( ...
    ...%%%%%%%% parameters for Brownian dynamics simulation %%%%%%%%%%%%%%%%
    'n_dims', 2 ...      %  number of dimensions in which the simulation is conducted  
    , 'sim_box_size_um',  NaN ...  % the simulated box is of this size. See code below for actual default value (should be box_size_px*um_per_px)
    , 'num_frames', 1 ...			% number of frames in the stack produced by the code
    , 'density', 1 ...              % density of the particles, in um^-o.n_dims
    , 'um_per_px', 0.0645 ...			% resolution, microns per pixel
    , 'sec_per_frame', 5 ...		% seconds per frame
    ...
    , 'diff_coeff', 0.1 ...              	% diffusion coefficient in micron^2/sec
    , 'u_convection', [1 0 0] ...        	% convection velocity in microns/sec
    , 'bonds_per_atom', 0 ...            	% # of bonds per atom
    , 'spring_const', 1 ...              	% spring constant 1/micron^2
    , 'topo', 'nn' ...               	% ('nn', 'random'). network topology nearest neighbor or random connections
    , 'make_gradient' , 0 ...  
    ...
    ...%%%%%%%% parameters for image generation %%%%%%%%%%%%%%%%%%%%%%%%%%%%
    , 'box_size_px', [2 2 2].^4 ...  	% size of the images.
    , 'psf_type', 'g' ...            	% only gaussian psf ('g') is currently supported
    , 'psf_sigma_um', [0.4 0.4 0.7] ...  	% standard deviation of the psf in microns, indepedent for all three directions
    , 'renderer', 'points_from_nodes' ...  	%   'lines_from_bonds' or 'points_from_nodes'.
    ...
    , 'signal_level', 200 ...                %signal level above background
    , 'signal_background', 0 ...
    , 'counting_noise_factor', 1.327  ...		% counting noise  factor (noise = sqrt(o.counting_noise_factor*imageFinal).*randn(im_dims) 
    , 'dk_background',  189.462 ...   % dark background average
    , 'dk_noise', 7.265 ...         % dark noise rms(std)
    ...
    , 'debug', 0 ...                     	% (0,1) -- if 1, plots the state of the system at each step, aside from producing the simulated microscope stack
    , 'ic', 'rand' ...               % initial conditions.  Leave at 'rand'.
    , 'time_step_max_kD', 0.01 ...  % Maximum time step size the integrator can take (Integrator takes smaller steps than o.sec_per frame.)
    , 'bleachType', 'none' ...       % bleaching is not implemented currently
    , 'bleachDecay', 0.1 ...         % bleaching is not implemented currently
    , 'qYield', 1 ...
    , 'finer_grid' , 3 ... %%% to more accurately simulate bead position
    , 'store_x', 1 ...
);


o = merge_ops(varargin, o_base);


imageFinalSize = [o.box_size_px(1),o.box_size_px(2)]; % define output image size
imageFinal = zeros(imageFinalSize(1),imageFinalSize(2),o.num_frames); % define output image
o.box_size_px = o.box_size_px*o.finer_grid; % expand image to have finer grid
o.um_per_px = o.um_per_px/o.finer_grid; % recale calibration factor


% make sure a line renderer is not used for point simulations
if o.bonds_per_atom == 0 
    o.renderer = 'points_from_nodes';
end

assert(numel(o.psf_sigma_um) >= o.n_dims);
assert(numel(o.box_size_px)  == 3);

% check the simulation box size for nonsense input
if isnan(o.sim_box_size_um)
    o.sim_box_size_um = o.box_size_px*o.um_per_px;
end
assert(~any(o.sim_box_size_um < o.box_size_px*o.um_per_px));
o.u_convection = merge_list(o.u_convection, [0 0 0 ]);

% Preallocate output arrays
image = zeros(o.box_size_px(2),o.box_size_px(1),o.num_frames);


% set up the log structure
logs.images = [];
logs.mean_bond_length = [];
logs.x = [];

%% setup initial state of the simulation
if isempty(state)
    % Sets up "state" structure
    for i=1:size(o.density,2)
        
        n_atoms(i) = round( ...
              prod(o.sim_box_size_um(1:o.n_dims)) ...
            * o.density(i) ...
            );
        
        % positions are stored in a matrix x(atom,dimension)
        if strcmp(o.ic, 'rand')
            state(i).x = rand(n_atoms(i), o.n_dims)*diag(o.sim_box_size_um(1:o.n_dims));
        end
        
        

        state(i).qYield = ones(n_atoms(i), 1).*o.qYield(i);
        state(i).blink = ones(n_atoms(i), o.num_frames);
        state(i).numToBleach(1) = 0;
        
        % -----------------------------------------------------------------
        % bonds
        % -----------------------------------------------------------------
        %
        % create a symmetric connection matrix:
        %   Initialize data structures:
        %   bonds(i,:) is a row vector of indices of atom indices to which
        %   i is bonded: i.e. (i,j) in B <=> j in bond(i,1:nbonds(i)).
        %   nbonds(i) is the length of the bond list that is stored
        %   explicitly since the number of elements in all rows of bonds must be the
        %   same to take advantage of MATLAB's matrices.
        %
        state(i).bonds = zeros(n_atoms(i)*o.bonds_per_atom(i),2);
        state(i).spring_const =o.spring_const(i);
        
        nbonds = zeros(n_atoms(i),1);
        bonds = zeros(n_atoms(i), o.bonds_per_atom(i));
        if o.bonds_per_atom(i) > 0
            
            % first fill the bond table with bonds to self
            %  bonds(i,:) == i : This is a convenient initial value since
            %  the harmonic bond force corresponding to padding element is by
            %  definition 0.
            for ibond = 1:size(bonds, 2)
                bonds(:,ibond) = 1:n_atoms(i);
            end
            if strcmp(o.topo, 'rand')
                % perfectly random connections among atoms
                for ii = 1:n_atoms(i)
                    for jj = (ii+1):n_atoms(i)
                        if nbonds(ii) < o.bonds_per_atom(i)
                            nbonds([ii jj]) = nbonds([ii jj]) + 1;
                            bonds(ii, nbonds(ii)) = jj;
                            bonds(jj, nbonds(jj)) = ii;
                        else
                            break;
                        end
                    end
                end
            elseif strcmp(o.topo, 'nn')
                % fill the bond table with the nearest neighbors, in order
                %   compute the distance matrix
                %   calculate the sort order
                D = zeros(n_atoms(i));
                for dim = 1:o.n_dims
                    X = meshgrid(state(i).x(:,dim));
                    X = X'-X;
                    
                    % apply the periodic boundary conditions
                    X = X-round(X/L(dim))*L(dim);
                    
                    % convert it to distance
                    D = D + X.^2;
                end
                
                for atom = 1:(n_atoms(i)-1)
                    % sort the distances between atom i and all others in
                    % increasing order
                    [bla, nni] = sort( D(atom, (atom+1):end));
                    nni = nni + atom;
                    % nni (nearest neighbor indices) now is the list of atom indices closest to atom
                    % from this list we remove nni < atom
                    nni(nni < atom) = [];
                    % now remove the candidate neighbors that have no available
                    % valences
                    nni(nbonds(nni) == o.bonds_per_atom) = [];
                    
                    n_bonds_needed = o.bonds_per_atom - nbonds(atom);
                    nni = nni(1:min(length(nni), n_bonds_needed));
                    % now create the bonds
                    for btom = nni
                        nbonds([atom btom]) =  nbonds([atom btom]) + 1;
                        bonds(atom, nbonds(atom)) = btom;
                        bonds(btom, nbonds(btom)) = atom;
                    end
                end
            end
        end
        state(i).bonds = bonds;
        state(i).nbonds = nbonds;
        if o.debug
            logs = plot_system(state(i), o, logs);
            fprintf('Mean bonds per atom: %g \n\n', mean(nbonds));
        end
        
    end
end

%% simulate the system and create the images
fprintf(1,'Runnging Brownian dynamics simulation....\n\n')
for t = 1:o.num_frames;
    
    for j = 1:size(o.density,2)
        
        % Adjust particle positions
        [state(j) logs(j)] = simul8trMovement(state(j),o, logs(j));
        if o.debug
            logs(j) = plot_system(state(j), o, logs(j));
        end
        % add the particles to the images
        image(:,:,t) = image(:,:,t) + feval(o.renderer, state, o); % same as point_from_nodes(state, o)
        image(:,:,t) = image(:,:,t)*o.finer_grid*o.finer_grid; % rescale intensity due to expansion of grid
    end
end


%% adding PSF and noise
fprintf(1,'Simulation done, generating images....\n\n')

if strcmp(o.psf_type,'g')
    psf = @(f)convolveGaussian(f,o.psf_sigma_um(1)/o.um_per_px);
elseif strcmp(PSFType,'l')
    psf = @(f) convolveGaussianLine(f,filter_size(1:2),o.psf_sigma_um(1)/o.um_per_px);
else
    psf = @(f) convolveAiry(f,filter_size(1:2),o.psf_sigma_um(1)/o.um_per_px);
end

%%%%%%%%%%%% Convolve new positions, resize back the image
 for t = 1:o.num_frames

    fprintf(1,['No.',num2str(t),' frame completed !\n'])        
    image(:,:,t)  = psf(image(:,:,t)); %???????????????

%         for i= 1: imageFinalSize(1)% resize back the image by loop
%             for j=1:imageFinalSize(2)
% 
%                 imageFinal(i,j,t) = mean(mean(image(o.finer_grid*(i-1)+1:o.finer_grid*i,o.finer_grid*(j-1)+1:o.finer_grid*j,t))); %%%%%%%%%%%%% resize back to the original size
%             end
%         end
    imageFinal(:,:,t) = imresize(image(:,:,t),1/o.finer_grid,'bilinear'); % resize back the image     
 end

%%%%%%%%%%% adding signal & noice
maxIntensity = max(max(max(imageFinal))); % scale signal level
intensity_rescale =o.signal_level/mean(imageFinal(imageFinal>maxIntensity/2));
imageFinal = imageFinal*intensity_rescale;

imageFinal = imageFinal + o.signal_background; % background fluorescence signal

imageFinal = imageFinal + sqrt(o.counting_noise_factor*imageFinal).*randn(imageFinalSize(1),imageFinalSize(2),o.num_frames); % add photon counting noise (signal noise)

imageFinal = imageFinal + o.dk_background + o.dk_noise*randn(imageFinalSize(1),imageFinalSize(2),o.num_frames); % add dark backround and noise


end
